# -*- coding: utf-8 -*-
"""Kmeansclustering implementation on customer segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bKXhaEF-lLdRha12HQwaOARQSInw6fzg

## Customer Segmentation Dataset

__Context__<br/>
- In today's competitive world, it is crucial to understand customer bahaviour and categorise customers based on their demography and buying behaviour. This is broadly one aspect of customer segmentation that allows marketers to better tailor their marketing efforts to various audience subsets in terms of promotional, marketing and product development strategies.

__Objective__<br/>
- This assignment demonstrates the concept of segmentation of a customer dataset from an e-commerce site using k-means clustering in python. You will use the kmeans and the hierarchical clustering algorithms to derive the optimum number of clusters and understand the underlying customer segments based on the data provided.

__About the dataset__<br/>
- The dataset consists of Annual income (in `$`000) and their annual spend (in `$`000) on an e-commerce site for a period of one year. Let us explore the data using numpy and pandas libraries in python.

### Import the dataset
"""

import pandas as pd
dataset= pd.read_csv('https://raw.githubusercontent.com/insaid2018/Term-3/master/Data/Assignment/CLV.csv')
dataset.head()

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# % matplotlib inline
dataset.mean().plot(kind='bar')

"""### Check the shape of the dataset"""

dataset.shape

"""### Check the columns present in the dataset"""

dataset.columns

"""### Check the descriptive statistics of the dataset"""

dataset.describe().transpose()

"""The mean annual income is `$`245000 and the mean annual spend is `$`149000.

### Check the info of the dataset
"""

dataset.info()

"""### code to check the missing values present in the dataset. """

def generate():
    return dataset.isnull().any()# Your variable to return
generate()

"""### Distribution of the annual income and annual spend with a distplot."""

import seaborn as sns
import matplotlib.pyplot as plt
def generate():
  f, axes = plt.subplots(0, 1, figsize=(6, 4))
  sns.distplot(dataset['INCOME'])
  sns.distplot(dataset['SPEND'])
  # Your code here
generate()

"""### Distribution of the annual income and annual spend with Violinplot."""

def generate():
  f, ax = plt.subplots(1, 2,   figsize=(12,6) )
  sns.violinplot(data= dataset['SPEND'], order=None, hue_order=None, bw='scott', cut=2, scale='area', scale_hue=True, 
                 gridsize=100, width=0.8, inner='box', split=False, dodge=True, orient=None, linewidth=None, color='red', palette=None, 
                 saturation=0.75, ax= ax[0])
  sns.violinplot(data= dataset['INCOME'], order=None, hue_order=None, bw='scott', cut=2, scale='area', scale_hue=True, 
                 gridsize=100, width=0.8, inner='box', split=False, dodge=True, orient=None, linewidth=None, color=None, palette=None, 
                 saturation=0.75, ax= ax[1])
  
    # Your code here
generate()

"""### Scatter plot of Spend versus Income to understand the spread, use color as black and size of marker as 100."""

def generate():
    # Your code here
    sns.scatterplot('INCOME', 'SPEND', data = dataset, color = 'r')
    return
generate()

"""__Plotting in 3D space__"""

from mpl_toolkits.mplot3d import Axes3D
import numpy as np

fig = plt.figure()
ax = Axes3D(fig)

X = np.array(list(zip(dataset['INCOME'], dataset['SPEND'])))
ax.scatter(X[:, 0], X[:, 1])

"""### kmeans model to cluster the samples in 4 clusters taking the below parameters:
- init='k-means++',
- max_iter=300, 
- n_init=10,
- random_state=0

### Return the model.


### Also Computing cluster centers and predict cluster index for each sample using fit_predict method(Return this variable also)
"""

from sklearn.cluster import KMeans
def generate():
    # Your code here
    model = KMeans(n_clusters=4, init = 'k-means++', max_iter = 300, n_init = 10, random_state = 0)
    model.fit_predict(dataset)
    km4 = pd.DataFrame(model.cluster_centers_)
    y_means = model.fit_predict(dataset)
    return km4, y_means # your variables here
km4, y_means = generate()

dataset['label'] = y_means

y_means

dataset.head()

"""### Visulaizing the clusters using scatter plot (Spend Vs Income). Taking marker size as 50, color for clusters 1 to 4 as purple, blue, green & cyan, label for various clusters as 'Cluster1', 'Cluster2', 'Cluster3', 'Cluster4'. For the cluster centres use marker = 's', marker size as 200 and color as red, alpha blending value as 0.7 and label as 'Centroids'. Title of the plot should be ' Customer segments '.Set "Annual income of customer" as label of x axis and "Annual spend from customer on site" as label of y axis. """

def generate():
    # your code here
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset['label'] == 0],s= 50, color = 'purple', label = 'Cluster1')
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset['label'] == 1],s= 50, color = 'blue', label = 'Cluster2')
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset['label'] == 2],s= 50, color = 'green', label = 'Cluster3')
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset['label'] == 3],s= 50, color = 'cyan', label = 'Cluster4')
    sns.scatterplot(km4[0], km4[1], data = km4, s =200, color = 'red', alpha = 0.7, label = 'Centroids')
    return 
generate()

"""__Interpretation of the 4 segments created__<br/>

The plot shows the distribution of the 4 clusters. We could interpret them as the following customer segments:

- __Cluster 1__: Customers with medium annual income and low annual spend
- __Cluster 2__: Customers with high annual income and medium to high annual spend
- __Cluster 3__: Customers with low annual income
- __Cluster 4__: Customers with medium annual income but high annual spend

__Cluster 4__ straight away is one __potential customer segment__. However, Cluster 2 and 3 can be segmented further to arrive at a more specific target customer group. Let us now look at how the clusters are created when k=6:
"""

from scipy import stats
review_data_std = stats.zscore(dataset[['SPEND','INCOME']])
review_data_std = np.array(review_data_std)

import pylab as pl
number_of_clusters = range(1,20)
kmeans = [KMeans(n_clusters=i,max_iter=1000,random_state=42) for i in number_of_clusters]
score = [-1*kmeans[i].fit(review_data_std).score(review_data_std) for i in range(len(kmeans))]
pl.plot((number_of_clusters),score)
pl.xlabel('Number of Clusters')
pl.ylabel('Score')
pl.title('Elbow Curve')
pl.show()

"""### kmeans model to cluster the samples in 6 clusters taking the below parameters:
- init = 'k-means++',
- max_iter = 300, 
- n_init = 10,
- random_state = 0

### Return the model.


### Also Computing cluster centers and predict cluster index for each sample using fit_predict method(Return this variable also)
"""

dataset1 = dataset[['SPEND', 'INCOME']]

def generate():
    # your code here
    KMeans6 = KMeans(n_clusters=6, init='k-means++', n_init=10, max_iter=300, random_state=0)
    y_means6 = KMeans6.fit_predict(dataset1)
    km6 = pd.DataFrame(KMeans6.cluster_centers_)
    return km6, y_means6 # your variables here
km6, y_means6 = generate()

dataset1['label'] = y_means6

"""### Visulaizing the clusters using scatter plot (Spend Vs Income). Taking marker size as 50, color for clusters 1 to 6 as purple, blue, green, cyan, magenta, orange respectively, label for various clusters as 'Cluster1', 'Cluster2', 'Cluster3', 'Cluster4','Cluster5','Cluster6'. For the cluster centres use marker = 's', marker size as 200 and color as red, alpha blending value as 0.7 and label as 'Centroids'. Title of the plot should be ' Customer segments '.Set "Annual income of customer" as label of x axis and "Annual spend from customer on site" as label of y axis. """

def generate():
    # your code here
   
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset1['label'] == 0], s= 50, color = 'purple', label = 'Cluster1')
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset1['label'] == 1], s= 50, color = 'blue', label = 'Cluster2')
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset1['label'] == 2], s= 50, color = 'green', label = 'Cluster3')
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset1['label'] == 3], s= 50, color = 'cyan', label = 'Cluster4')
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset1['label'] == 4], s= 50, color = 'red', label = 'Cluster5')
    sns.scatterplot('INCOME', 'SPEND', data = dataset[dataset1['label'] == 5], s= 50, color = 'orange', label = 'Cluster6')
    sns.scatterplot(km6[1], km6[0], data = km6, s =200, color = 'red', alpha = 0.7, label = 'Centroids')
   
    return 
generate()

"""__Interpretation of the 6 segments created__<br/>

Setting the number of clusters to 6 seems to provide a more meaningful customer segmentation.

- <span style="color:purple">**__Cluster 1__:** </span>:: Medium income, low annual spend
- <span style="color:blue">**__Cluster 2__:** </span>:: Low income, low annual spend
- <span style="color:green">**__Cluster 3__:** </span>:: High income, high annual spend
- <span style="color:cyan">**__Cluster 4__:** </span>:: Low income, high annual spend
- <span style="color:magenta">**__Cluster 5__:** </span>:: Medium income, low annual spend
- <span style="color:orange">**__Cluster 6__:** </span>:: Very high income, high annual spend<br/>
Thus it is evident that 6 clusters provides a more meaningful segmentation of the customers.

### Elbow method to find the optimal number of cluster for our dataset. Use the below parameters for the kmeans model.
- init='k-means++',
- max_iter=300, 
- n_init=10,
- random_state=0
### Plot the graph between " Sum of squared distances of samples to their closest cluster center for number of clusters ranging between 1 to 11" Versus the number of clusters.
"""

number_of_clusters = range(1, 11)
    
Kmeans = [KMeans(n_clusters=i, init='k-means++', n_init=10, max_iter=300, random_state=0) for i in number_of_clusters]
for i in range(len(Kmeans)):
  Kmeans[i].fit(dataset[['SPEND', 'INCOME']]) 
wcss = [Kmeans[i].inertia_ for i in range(len(Kmeans))]
pl.plot(number_of_clusters, wcss)
plt.title('Elbow method')
plt.xlabel('wcss')
plt.ylabel('No. of clusters')
plt.show()

"""### Q10. Dendrogram plot to find the optimal number of clusters. Set  "Hierarchical Clustering Dendrogram (truncated) " as title, "sample index or (cluster size)" as  xlabel and "distance" as ylabel. For linkage use the 'ward' method, Also show only the last 12 merged clusters in the dendrogram, keep leaf_font_size as 12. In the plot also draw a line to select a Distance Cut-Off at 400 to Determine the Number of Clusters.
   
"""

import scipy.cluster.hierarchy as sch
sch.dendrogram
 
def generate():
    plt.title('Hierarchical Clustering Dendrogram (truncated)')
    plt.xlabel('sample index or (cluster size)')
    plt.ylabel('distance')
    Z = sch.linkage(dataset1[['SPEND', 'INCOME']], 'ward')

    sch.dendrogram(Z, p=12, truncate_mode='lastp', color_threshold=None, get_leaves=True, orientation='top', labels=None, count_sort=False, distance_sort=False, 
                   show_leaf_counts=True, no_plot=False, no_labels=False, leaf_font_size=12, leaf_rotation=None, leaf_label_func=None, 
                   show_contracted=False, link_color_func=None, ax=None, above_threshold_color='b') 
    # your code here
    plt.axhline(400, c = 'k')
    plt.show()
    return
generate()

"""We can see the best choice for the number of cluster is 3.

### Hierarical clustering model to cluster the samples in 3 clusters using Agglomerative Clustering object and by taking the below parameters:
- affinity = 'euclidean',
- compute_full_tree = 'auto',
- connectivity = None,
- linkage = 'ward',
- memory = None,
- pooling_func = 'deprecated'

### Return the model.


### Also computing cluster centers and predict cluster index for each sample using fit_predict method(Return this variable also)
"""

from sklearn.cluster import AgglomerativeClustering
def generate():
    # your code here
    hc = AgglomerativeClustering(n_clusters = 3, affinity='euclidean', memory=None, connectivity=None, compute_full_tree='auto', 
                                  linkage='ward', distance_threshold=None)
    y_hc = hc.fit_predict(dataset1[['SPEND', 'INCOME']])
    return hc, y_hc # your variables here
hc, y_hc = generate()

dataset2 = dataset1[['SPEND', 'INCOME']]

dataset2['label'] = y_hc

"""### Visulaizing the clusters using scatter plot (Spend Vs Income). Take :
- marker size as 50,
- color for clusters 1 to 3 as red, blue, green respectively,
- label for various clusters as 'Cluster1', 'Cluster2', 'Cluster3'.
- Title of the plot should be ' Clusters of customers '.
- Set "Annual income of customer in `$`000" as label of x axis and
- "Annual spend in`$`000" as label of y axis. 
"""

def generate():
    # your code here
    sns.scatterplot('SPEND', 'INCOME', data = dataset2[dataset2['label'] == 0], s = 50, color = 'red', label = 'Cluster1' )
    sns.scatterplot('SPEND', 'INCOME', data = dataset2[dataset2['label'] == 1], s = 50, color = 'blue', label = 'Cluster2' )
    sns.scatterplot('SPEND', 'INCOME', data = dataset2[dataset2['label'] == 2], s = 50, color = 'green', label = 'Cluster3' )
    return
generate()

"""__Interpretation of the 3 segments created__<br/>

The plot shows the distribution of the 3 clusters. We could interpret them as the following customer segments:

- <span style="color:red">**__Cluster 1__:** </span>: Customers with medium annual income and low to high annual spend
- <span style="color:blue">**__Cluster 2__:** </span>: Customers with low annual income and low to high annual spend
- <span style="color:green">**__Cluster 3__:** </span>: Customers with high annual income and medium to high annual spend
"""